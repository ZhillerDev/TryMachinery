## 预备知识

### 同步原语 Synchronization Primitives

同步原语(Synchronization Primitives)是执行线程之间协调和同步的一种方法

主要功能：控制多个执行单元对共享资源的访问，同步执行单元的执行顺序和状态

常见同步原语

- 信号量(Semaphore):用于限制资源的访问数量。
- 互斥锁(Mutex):允许对共享资源的独占访问。
- 条件变量(Condition Variable):线程可等待其他线程改变某个条件后被唤醒。
- 栅栏(Barrier):保证在继续之前,多个线程达到同样的执行点。
- 自旋锁(Spinlock):线程等待时在 CPU 上忙循环,而不是阻塞。

<br>

### 自旋锁 spinlock

自旋锁是一种同步原语,用于保护共享资源免受并发访问的冲突。

自旋锁特性：线程在等待锁时并不阻塞。而是进入忙等待(spin)状态,不断检查锁是否被释放

<br>

自旋锁工作方法

1. 当一个线程请求获取自旋锁时,首先会尝试抢占锁。
2. 如果锁空闲,则获取锁成功。
3. 如果锁已被占用, requesting 线程将进入忙等待状态,不断检查锁是否被释放。
4. 一旦锁被释放,正在自旋的线程就会获得锁,从而继续执行。

<br>

### 自旋表 spintable

自旋表(spin table)是一种基于自旋锁实现的同步原语。  
自旋表用于多个线程需要同时访问但不能保证的一组数据。它通过为每个数据项分配一个独立的锁来实现。

自旋表实现

1. 为需要同步的每个数据项分配一个锁(例如原子操作计数器)。
2. 线程访问数据项前,先尝试获取对应锁。
3. 如果获取失败(锁被其他线程持有),则线程进入自旋模式,反复尝试获取锁。
4. 一旦获取锁成功,线程才能访问对应数据项。访问完后释放锁。

<br>

### 电源状态协调接口 PSCI

一种标准化的接口,用于在处理器和操作系统内核之间协调电源管理

主要作用

1. 允许内核控制集群级(Cluster Level)的电源管理状态,例如进入深睡眠(Deep Sleep)模式。
2. 管理不同的处理器核心,包括上电/下电,在运行时进入/退出低功耗状态等。
3. 提供标准的调用接口,实现不同核心和操作系统之间的统一。

重要的函数调用
`CPU_ON()`: 将 CPU 置于运行状态。
`CPU_OFF()`: 下电指定的 CPU。  
`CPU_SUSPEND()`: 暂停指定的 CPU。  
`SYSTEM_SUSPEND()`: 将整个系统置于低功耗状态。

<br>

### 停车协议 ACPI

一种电源管理标准,用于操作系统和硬件之间描述和管理电源

ACPI 两个主要组成  
`ACPI Specification` 定义了一套电源管理接口和规范。  
`ACPI BIOS` 提供了系统低功耗状态的实际硬件实现。

<br>

进入停车模式前 BIOS 需要做的

1. 挂起 PCI 总线和设备。
2. 关闭不必要的器件。
3. 保存硬件系统状态。
4. 进入停车模式。

<br>

## 内核引导与初始化

<br>

### 引导程序读取

读取引导程序指令步骤

1. 处理器在上电时自动把程序计数器设置为处理器厂商设计的某个固定值
2. 处理器的内存管理单元（Memory Management Unit, MMU）负责把虚拟地址转换为物理地址
3. ARM64 处理器到物理地址 0 取第一条指令

> 嵌入式设备通常使用 NOR 闪存作为只读存储器来存放引导程序

<br>

### 引导程序

#### `_start`

`_start`是 uboot 程序的入口点

<br>

#### 标号 reset

简要执行过程（省去 reset 源码）

1. 调用各种板卡自定义的函数 save_boot_params 来保存重要的寄存器
2. 调用函数 reset_sctrl 来初始化系统控制寄存器
3. 根据处理器当前的异常级别设置寄存器
4. 为处理器的缺陷打补丁
5. 调用函数 lowlevel_init 以执行函数 board_init_f()所需要的最小初始化
6. 配置主处理器和从处理器
7. spin_table_secondary_jump 函数是自旋表启动方式下的次要处理器入口,它会等待主处理器指定函数地址,然后跳转执行
8. 最后主处理器执行函数`_main`

<br>

**第二阶段程序加载器 SPL**

U-Boot 分为 SPL 和正常的 U-Boot 程序两个部分

定义：由于部分处理器内部 SRAM 较小，无法装载完整 uboot，故 SPL 主要负责初始化内存和存储设备驱动，然后把正常的 U-Boot 镜像从存储设备读到内存中执行

<br>

#### 主函数 `_main`

首先做厨师准备，分配内存空间

执行 `board_init_f` 前期初始化函数，把 uboot 程序复制到内存中  
若编译正常 uboot，则调用 `relocate_code`  
若编译 SPL，则调用 `spl_relocate_stack_gd` 重新定位栈

最终使用 `board_init_r` 执行后期初始化

<br>

#### run_main_loop

uboot 初始化完毕，使用 run_main_loop 函数处理命令

![](./img/core/c1.png)

环境变量 `bootdelay` 定义延迟时间，即等待用户按键的时间长度；环境变量 `bootcmd` 定义要执行的命令

`autoboot_command` 对命令表进行查询操作

通常把 NOR 闪存分成多个分区，其中第一个分区存放 U-Boot 程序，第二个分区存放环境变量

<br>

#### 平展设备树(Flattened Device Tree, FDT)

其是一种以文本格式表达设备树的方法

在 uboot 中,可以加载平展设备树文件 (.dts 文件),然后将其解析为内存中的数据结构,为系统提供设备描述信息

<br>

### 内核初始化

#### 汇编部分

ARM64 架构的内核的入口是标号`_head`，直接跳转到标号`stext`

配置宏 CONFIG_EFI 表示提供 UEFI 运行时支持

UEFI 相比于 BIOS 有以下优势

- 支持最大分区大小超过 2TB
- 使用 GUID 分区表而不是 MBR 分区表
- 提供更安全的引导方式,能加密引导加载程序
- 识别和引导更多文件系统,如 ext4、NTFS 等
- 提供图形用户界面
- 支持更多操作系统,如 Windows、Linux 等

<br>

el2_setup 函数

- 如果异常级别是 1，那么在异常级别 1 执行内核
- 如果异常级别是 2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions, VHE），决定是否需要降级到异常级别 1

<br>

#### 异常级别与虚拟化宿主扩展

> 通常 ARM64 处理器在异常级别 0 执行进程，在异常级别 1 执行内核

运行虚拟机的操作系统称为宿主操作系统（host OS）  
虚拟机里面的操作系统称为客户操作系统（guest OS）

现在常用的虚拟机是基于内核的虚拟机（Kernel-based Virtual Machine, KVM）  
KVM 的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快  
KVM 是内核的一个模块，把内核变成虚拟机监控程序

![](./img/core/c2.png)

<br>

常用的开源虚拟机管理软件是 QEMU, QEMU 支持 KVM 虚拟机

ARM64 架构引入了虚拟化宿主扩展，在异常级别 2 执行宿主操作系统的内核

<br>

#### 内核初始化 C 语言部分

该入口是函数 `start_kernel`  
start_kernel 首先初始化内核的各个子系统，然后调用函数 rest_init

rest_init 的执行流程

- 创建 1 号线程，即 init 线程，线程函数是 kernel_init。
- 创建 2 号线程，即 kthreadd 线程，负责创建内核线程。
- 0 号线程最终变成空闲线程。

<br>

#### SMP 与 ASMP

SMP 意为`对称多处理(Symmetric Multi-Processing)`,指的是一种具有多个处理器的系统,这些处理器共享存储器和 I/O 系统

`ASMP(非对称多处理)`,它有多个专用处理器和存储器

SMP 系统的主要特征

- 多个处理器对存储器和 I/O 系统有同等访问权限。
- 各个处理器运行速度相同,所使用的指令集也相同。
- 处理器之间通过中断、消息传递等方式进行协调和通信。
- 操作系统需要能够管理多个处理器,如任务调度、资源分配等。
- 所有的处理器共享内存空间,无专属内存。

<br>

#### SMP 系统引导

SMP 中，各个处理器低位平等，但启动过程时地位不平等  
0 号处理器称为引导处理器，负责执行引导程序和初始化内核  
其他处理器称为从处理器，等待引导处理器完成初始化

引导处理器启动从处理器的方法

1. 自旋表（spin-table）。
2. 电源状态协调接口（Power State Coordination Interface, PSCI）
3. ACPI 停车协议（parking-protocol）, ACPI 是高级配置与电源接口（Advanced Configuration and Power Interface）。

<br>

### init 进程

init 进程是用户空间的第一个进程，负责启动用户程序

<br>

## 进程管理

<br>

### 进程

进程描述符 `task struct` 的主要成员

![](./img/core/c3.png)

<br>

关于进程的一些基本概念

1. Linux 内核把进程称为任务（task）
2. 进程的虚拟地址空间分为用户虚拟地址空间和内核虚拟地址空间
3. 所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间
4. 没有用户虚拟地址空间的进程称为内核线程
5. 共享用户虚拟地址空间的进程称为用户线程
6. 共享同一个用户虚拟地址空间的所有用户线程组成一个线程组

<br>

### 命名空间

创建新命名空间的两个方式

1. 调用 clone 创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新的命名空间
2. 调用 unshare 创建新的命名空间，不和已存在的任何其他进程共享命名空间

<br>

进程号命名空间用来隔离进程号，对应的结构体是 `pid_namespace`

每个进程号命名空间独立分配进程号

<br>

### 进程标识符

进程标识符：进程所属的进程号命名空间到根的每层命名空间，都会给进程分配一个标识符

线程组标识符：多个共享用户虚拟地址空间的进程组成一个线程组，线程组中的主进程称为组长，线程组标识符就是组长的进程标识符

进程组标识符：多个进程可以组成一个进程组，进程组标识符是组长的进程标识符

会话标识符：多个进程组可以组成一个会话

<br>

下图展示进程标识符数据结构

![](./img/core/c4.png)

<br>

### 进程关系

一个进程的所有子进程被链接在一条子进程链表上，头节点是父进程的成员 children，链表节点是子进程的成员 sibling

![](./img/core/c5.png)

进程管理子系统把所有进程链接在一条进程链表上  
对于线程组，只把组长加入进程链表

<br>

### 启动程序

> 包括创建新进程、装载程序两大部分

#### 创建新进程

Linux 内核中进程创建的方式

1. 内核使用静态数据构造出 0 号内核线程
2. 0 号内核线程分叉生成 1 号内核线程和 2 号内核线程（kthreadd 线程）
3. 1 号内核线程完成初始化以后装载用户程序，变成 1 号进程
4. 其他进程都是 1 号进程或者它的子孙进程分叉生成的，也是 kthreadd 线程分叉生成

<br>

新进程创建的三个办法

1. fork（分叉）：子进程是父进程的一个副本，采用了写时复制的技术
2. vfork：用于创建子进程，之后子进程立即调用 execve 以装载新程序的情况。
3. clone：父子进程之间共享

<br>

`“asmlinkage”`表示这个 C 语言函数可以被汇编代码调用

如果使用 C++编译器，“asmlinkage”被定义为 extern "C"；  
如果使用 C 编译器，“asmlinkage”是空的宏。

系统调用的函数名称以“sys\_”开头

<br>

创建新进程的主要工作由函数 `copy_process` 实现

内核栈的两种布局

1. 结构体 thread_info 占用内核栈的空间，在内核栈顶部，成员 task 指向进程描述符
2. 结构体 thread_info 没有占用内核栈的空间，是进程描述符的第一个成员

结构体 `thread_info` 存放汇编代码需要直接访问的底层数据

下面是 ARM64 中对于 thread_info 结构体的定义

```cpp
<arch/arm64/include/asm/thread_info.h>
struct thread_info {
        unsigned long   flags;                 /*底层标志位*/
        mm_segment_t         addr_limit;      /*地址限制 */
#ifdef CONFIG_ARM64_SW_TTBR0_PAN
        u64         ttbr0;                    /* 保存的寄存器 TTBR0_EL1 */
#endif
        int         preempt_count;            /* 0表示可抢占，小于0是缺陷 */
};
```

全局变量 `nr_threads` 存放当前的线程数量；  
`max_threads` 存放允许创建的线程最大数量

函数 sched_fork 为新进程设置调度器相关的参数

函数 copy_semundo 处理 UNIX 系统 5 信号量的共享问题

函数 copy_sighand 复制或者共享信号处理程序，因为只有属于同一个线程组的线程之间才会共享信号处理程序  
函数 copy_mm 复制或共享虚拟内存，因为只有属于同一个线程组的线程之间才会共享虚拟内存

函数 copy_io 创建或者共享 I/O 上下文

函数 copy_thread_tls 复制当前进程的寄存器值，并且修改一部分寄存器值

<br>

函数 `wake_up_new_task` 负责唤醒刚刚创建的新进程

新进程第一次运行，是从函数 `ret_from_fork` 开始执行。函数 ret_from_fork 是由各种处理器架构自定义的函数

函数 `schedule_tail` 负责为上一个进程执行清理操作，是新进程第一次运行时必须最先做的事情

<br>

#### 装载程序

新进程使用系统调用 execve 装载程序

下面展示了两个系统调用函数

```cpp
// argv是传给新程序的参数指针数组
// envp是传给新程序的环境指针数组
// argv和envp都必须在数组的末尾包含一个空指针
int execve(const char *filename, char *const argv[], char *const envp[]);
int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp
[], int flags);
```

两个系统调用最终都调用函数 `do_execveat_common`  
该函数的主要功能流程为：打开可执行文件，使用 sched_exec 处理负载均衡； bprm_mm_init 创建新的内存描述符，分配临时的用户栈；  
函数 prepare_binprm 设置进程证书  
用函数 exec_binprm

<br>

### 进程退出

父进程退出后，子进程需要被另一个父进程领养，否则会变成孤儿进程，下面是领养的三个可适用的规则

- 如果进程属于一个线程组，且该线程组还有其他线程，那么选择任意一个线程
- 选择最亲近的充当“替补领养者”的祖先进程
- 选择进程所属的进程号命名空间中的 1 号进程

<br>

#### 线程组退出

系统调用 `exit_group` 实现线程组退出，主要工作委托给函数 `do_group_exit`

线程组退出的简单解释：譬如一个线程组有 3 个线程，线程 1 调用 exit_group 使线程组退出，那么将依次执行以下流程

1. 把退出码保存在信号结构体的成员 group_exit_code 中
2. 把 group_exit_code 传递给其余所有的线程
3. 为线程组设置正在退出标志
4. 给其余线程发送杀死信号，唤醒这些线程，让这些线程处理杀死信号
5. 线程 1 先行调用 do_exit 退出

<br>

函数 do_exit 的执行过程

1. 释放各种资源，把资源对应的数据结构的引用计数减一，如果引用计数变成 0，那么释放数据结构
2. 调用函数 exit_notify，先为成为“孤儿”的子进程选择“领养者”，然后把自己的死讯通知父进程
3. 把进程状态设置为死亡（TASK_DEAD）
4. 最后一次调用函数\_\_schedule 以调度进程

<br>

#### 终止进程
