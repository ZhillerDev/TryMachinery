### 用户模式实现的功能

Linux 提供了绝大多数库函数；

调用系统函数需要使用汇编语言，而 `Linux 通过 OS 提供了系统调用的包装函数`，用户可以使用任意类型的高级语言并通过该包装函数转译成汇编语言来获取系统调用

![](./img/howtowork/hk1.png)

<br>

Linux 提供了 C 标注库，而 GUN 还是默认使用 glibc 作为 C 标准库，用 C 语言编写的几乎所有程序都依赖于 glibc 库

<br>

### 进程管理

进程创建的方式

- 为子进程申请内存空间，并复制父进程的内存到子进程的内存空间。
- 父进程与子进程分裂成两个进程，以执行不同的代码。这一点的实现依赖于 fork() 函数分别返回不同的值给父进程与子进程。

![](./img/howtowork/hk2.png)

<br>

内核运行程序时的流程

1. 读取可执行文件，并读取创建进程的内存映像所需的信息。
2. 用新进程的数据覆盖当前进程的内存。
3. 从最初的命令开始运行新的进程。

> 即启动另一个程序时，并非新增一个进程，而是替换了当前进程

<br>

### 进程调度器

进程调度的四个普适性结论

- 不管同时运行多少个进程，在任意时间点上，只能有一个进程运行在逻辑 CPU 上
- 在逻辑 CPU 上运行多个进程时，它们将按轮询调度的方式循环运行，即所有进程按顺序逐个运行，一轮过后重新从第一个进程开始轮流运行
- 每个进程被分配到的时间片的长度大体上相等
- 全部进程运行结束所消耗的时间，随着进程数量的增加而等比例地增加

<br>

上下文切换

每个进程都被赋予几乎等长的时间片，一旦时间片走完就立刻执行上下文切换，而不管当前进程是否还有代码执行完毕与否  
所以下方代码中，执行完 `foo()` 后可能刚好耗尽时间片，切换到另一进程，则 `bar()` 就不会立刻执行

![](./img/howtowork/hk3.png)

<br>

进程的状态

进程具有以下四种状态，而大多数都处于睡眠态

![](./img/howtowork/hk4.png)

进程之间可以执行切换

![](./img/howtowork/hk5.png)

<br>

空闲状态

当逻辑 CPU 上无任何进程运行时，进入空闲状态，此时会执行一些无意义死循环或者开一个新进程，直到一个就绪态的子进程加入  
（系统自然不会这么傻白白耗电，他会主动休眠并等待就绪态进程出现，期间耗电量很小）

逻辑 CPU 的吞吐量随着处理线程数量的增多而升高，当且仅当 CPU 被进程填满后，无论增加多少进程吞吐量都不会变

<br>

多 CPU

当存在多个逻辑 CPU 时，linux 会使用“负载均衡”分配进程压力到各个 CPU 上面

> 对于多核 CPU 的计算机来说，只有同时运行多个进程才能提高吞吐量  
> 当进程数量多于逻辑 CPU 数量时，吞吐量就不会再提高

<br>
